Module: 2 — The Digital Twin (Gazebo & Unity)Objective:Teach students how to build accurate digital twins of humanoid robots, simulate physics and sensors, and validate AI behavior before real-world deployment.Audience:CS/AI students new to robotics and simulation.Prerequisites:Basic Python, ROS 2 fundamentals, Linux CLI.————————————————————Chapter 2.1 — Physics-Based Simulation with GazeboGoals:- Understand rigid-body physics, gravity, collisions, and constraints- Build a humanoid simulation using URDF/SDF- Run and visualize ROS 2–controlled robots in GazeboContent:- Gazebo architecture and physics engines- Loading URDF humanoids- Joint limits, collision meshes, inertia- ROS 2 ↔ Gazebo bridgeDeliverables:- Runnable Gazebo world- Simulated humanoid standing and moving- Verified physics parameters————————————————————Chapter 2.2 — Sensor Simulation & Perception InputsGoals:- Simulate realistic sensors for AI perception- Publish sensor data to ROS 2 topicsContent:- LiDAR, depth camera, IMU simulation- Noise models and sensor fidelity- Topic inspection and validationDeliverables:- Sensor-enabled humanoid- Live ROS 2 sensor topics- Visualized sensor outputs————————————————————Chapter 2.3 — High-Fidelity Digital Twins with UnityGoals:- Create visually realistic environments- Enable human–robot interaction testingContent:- Gazebo vs Unity roles- Unity environment setup- Synchronizing robot state- Rendering for perception and UX testingDeliverables:- Unity-based digital twin scene- Synced robot visualization- Simulation-ready environment————————————————————Assessment:- Functional digital twin- Accurate physics and sensor data- ROS 2 integration verifiedConstraints:- ROS 2 Humble/Iron- Gazebo Fortress- Unity LTS- No fictional APIsSuccess Criteria:- Simulations reproducible- Code runs without modification- Physics and sensors validated